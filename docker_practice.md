# Dockerについて学習する

## 概要
```control

用語:
    Docker: 
        ・ホストのカーネルを利用し、プロセスやユーザを隔離することで、別のマシンが動いているように見せかけるもの
        ・仮想マシンではないので、軽量
        ・ミドルウェアのインストールや、各種環境設定をコード化して管理できる(IaC)
        ・同じ環境をすぐに作れる。配布も容易(サーバの各種設定やインストールなどをコードで共有できるので、)
        ・よって、環境構築等の無駄な時間をなくせる
        ・コンテナ内での、アプリのパッケージ化と、実行機能を提供する
        ・クラスタ構成が容易(コンテナ名を変えるだけ)
        ・コード化したものをCI/CDツールで毎日実行すれば、リリースサイクルも容易になる

    Dockerデーモン(dockerd):
        Docker APIリクエストを受け付け、イメージやコンテナなどのDockerオブジェクトを管理する
        他のデーモンとも通信を行う

    Dockerクライアント(docker)
        docker run等のコマンドを通じ、dockerdに命令を伝える
        複数のデーモンと通信可能

    Dockerデスクトップ
        コンテナ化したアプリケーションと、マイクロサービスを構築、共有可能
        dockerd, docker, Docker Compose, Docker Content Trust, Kubernetes, CredentialHelperが含まれる
    
    Dockerレジストリ
        Dockerイメージを保管する(GHCR等もこの一種)
        デフォルトでは、DockerHubのイメージを探す
        docker pull -> 設定されたレジストリからイメージを取得
        docker push -> イメージを指定したレジストリに送信

    Dockerイメージ
        ・Dockerコンテナを作成する命令が入っている読み込み専用のテンプレート
        ・他のイメージ(たとえばubuntu)をベースとして、カスタマイズしたイメージを利用する
        ・例) ubuntuイメージをベースにapacheをインストールし、その設定を加えたもの
        
        イメージを作成する場合
            Dockerfileを作成
            ※Dockerfileを書き換えた場合、イメージは再構築されるが、その時は変更されたレイヤのみを再生成するので、ほかの仮想化技術に比べて軽量になっている

    コンテナ
        ・Dockerイメージが実行状態となったインスタンス
        ・生成、開始、停止などを行いたい場合、Docker APIやCLIを用いる
        ・複数のネットワークへの接続やストレージ追加、現時点の状態をもとにした新たなイメージの生成が可能。
        ・デフォルトではコンテナ同士は分離される
        ・コンテナを削除すると永続的なストレージに保存されていないものは消失する

    docker runコマンドの例
        docker run -it ubuntu /bin/bash

    上記の説明
        0. docker run = docker pull + docker create + docker startのようなもの
        1. docker run ubuntu
            ubuntuイメージがlocalになければ設定察れているレジストリからイメージ取得=docker pull ubuntu
        2. Dockerは新しいコンテナを取得=docker create
        3. Dockerはコンテナに対し、読み書き可能なファイルシステムを最後のレイヤとして割り当てる。=実行中のコンテナは、ファイルの変更が可能
        4. Dockerはネットワークインターフェースを生成し、コンテナを接続する。コンテナに対するIPアドレスの割り当てもなされる
        5. Dockerはコンテナを起動し、/bin/bashを実行する。
            -i 標準入力を受け付ける
            -t 標準入出力となっている端末デバイスを指定
            上記のオプションがあるので対話的に行える
        6. exitで/bin/bashコマンドは終了する(停止状態であり、削除は行われない)
    
    なぜコンテナが隔離された作業空間を準備できるのか
        namespacesを用いているため


    
具体例:
    1. 作業環境を共有するために、開発段階で用いる
    2. テストも、テスト環境のDockerで行う
    3. バグがあったら開発環境に戻し、テスト環境に再デプロイする
    4. ユーザに修正版を配布する

仕組み:
    ・クライアントはdocker build等の命令を通して、デーモンにDockerコンテナの配布、構築、実行などを行わせる
    ・デーモンとクライアントは必ずしも同一システム上にある必要はない
    ・Dockerクライアントとデーモンの間の通信にはREST APIが用いられる

```
## Docker Desktopのインストールに際して
```
- WSL2が有効化されている
- 何らかのLinuxディストリビューションがsetupされている

windows11なら以下のコマンドを打ち込むだけでいい
    wsl --install
```

## Getting Started
```
docker run -dp 80:80 docker/getting-started

    -d : コンテナをバックグラウンドで実行
    -p 80:80 : ホストの80番ポートをコンテナの80番ポートに割り当てる
    docker/getting-started : 使用するdockerイメージ

-> 実行すると、Docker DesktopのDashBoardに情報が追加された
-> Desktop上から使用ポートを確認したり、停止が可能
```

## 用語補足
```
sandbox: 
    通常利用する領域から隔離され、保護された空間に構築された仮想環境

隔離をなぜ実現できるのか
    カーネルのnamespaceとcgroupの活用
    コンテナ: 単一のホスト上で実行されるプロセスの分離されたグループ

    cgroup:
        ・プロセスをグループ化し、リソース制御を行う
        ・CPU,メモリ,ディスクI/O,ネットワーク帯域幅などのリソースを制御し、各プロセスグループに割り当てる
        ・Dockerコンテナはcgroupsを使用して、各コンテナのリソース制御を管理する。これによりコンテナ間でのリソース競合を防ぐ
    Namespaces:
        ・プロセスやリソースの隔離を実現するためのLinuxカーネル機能
        ・異なるコンテナ間でプロセスやファイルシステム、ネットワークなどの名前空間を分離
        ・Dockerコンテナは異なる名前空間で実行されるので、各コンテナは独自のプロセスID,ファイルシステム、ホスト名などを持つ。よって互いの影響を受けずに実行可能
        ・例) PID Namespaces->プロセスIDを隔離する

    cgroups + Namespaces:
        Dockerは名前空間でプロセスグループを隔離し、cgroupsでプロセスグループ(コンテナ)にリソースを制御、割り当てている。
        それによってリソースの競合はおきず、独自の環境が保たれる

    

Docker利点まとめ
    local,仮想マシン上で実行可能
    クラウドにもデプロイ可能
    多くのOSで実行可能
    imageには、依存関係、設定ファイル、スクリプト、バイナリ、環境変数、メタデータ等が含まれる


```